/*
 * Copyright (C) 2014 Dashman
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package srw.mxp.script.editor;

import java.awt.Color;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.nio.charset.Charset;
import java.nio.file.FileSystems;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Map;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;

/**
 *
 * @author Jonatan
 */
public class UserInterfaceSE extends javax.swing.JFrame {
    ArrayList<Dialogue> script;
    byte[] first_section;
    int current_dialogue = 0;
    int table_size = 0;
    String lastDirectory = ".";
    boolean file_loaded = false;
    String title = "SRW MXP Script Editor v1.0e by Dashman";
    String current_file = "";
    
    String font_encoding = "MS932";

    /**
     * Creates new form UserInterfaceSE
     */
    public UserInterfaceSE() {
        Dialogue d = new Dialogue();
        d.initMap();    // The map is static in the class, which means it only has to be initialized once.
        
        initComponents();
        
        this.setIconImage(new ImageIcon(getClass().getClassLoader().getResource("resources/icons/MX logo.png")).getImage());
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        panelNavigation = new javax.swing.JPanel();
        buttonPrevious = new javax.swing.JButton();
        labelCurrent = new javax.swing.JLabel();
        buttonNext = new javax.swing.JButton();
        labelJumpTo = new javax.swing.JLabel();
        textfieldJump = new javax.swing.JTextField();
        buttonJump = new javax.swing.JButton();
        panelSettings = new javax.swing.JPanel();
        checkSJIS = new javax.swing.JCheckBox();
        checkSkip = new javax.swing.JCheckBox();
        labelWidth = new javax.swing.JLabel();
        labelWidthTotal = new javax.swing.JLabel();
        labelWidthCurrent = new javax.swing.JLabel();
        panelOriginal = new javax.swing.JPanel();
        scrollOriginal = new javax.swing.JScrollPane();
        textareaOriginal = new javax.swing.JTextArea();
        panelEdited = new javax.swing.JPanel();
        scrollEdited = new javax.swing.JScrollPane();
        textareaEdited = new javax.swing.JTextArea();
        jMenuBar1 = new javax.swing.JMenuBar();
        menuFile = new javax.swing.JMenu();
        menuitemOpen = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JPopupMenu.Separator();
        menuitemImport = new javax.swing.JMenuItem();
        menuitemExport = new javax.swing.JMenuItem();
        jSeparator3 = new javax.swing.JPopupMenu.Separator();
        menuitemSave = new javax.swing.JMenuItem();
        menuitemConvert = new javax.swing.JMenuItem();
        jSeparator2 = new javax.swing.JPopupMenu.Separator();
        menuitemClose = new javax.swing.JMenuItem();
        menuNavigate = new javax.swing.JMenu();
        menuitemPrevious = new javax.swing.JMenuItem();
        menuitemNext = new javax.swing.JMenuItem();
        menuitemFirst = new javax.swing.JMenuItem();
        menuitemLast = new javax.swing.JMenuItem();
        menuTools = new javax.swing.JMenu();
        menuitemSJIS = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("SRW MXP Script Editor 1.0e by Dashman");
        setResizable(false);

        panelNavigation.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Navigation", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 0, 11), new java.awt.Color(51, 102, 255))); // NOI18N

        buttonPrevious.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        buttonPrevious.setForeground(new java.awt.Color(102, 204, 0));
        buttonPrevious.setText("<<");
        buttonPrevious.setEnabled(false);
        buttonPrevious.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonPreviousActionPerformed(evt);
            }
        });

        labelCurrent.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        labelCurrent.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        labelCurrent.setText("0 / 0");
        labelCurrent.setEnabled(false);

        buttonNext.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        buttonNext.setForeground(new java.awt.Color(102, 204, 0));
        buttonNext.setText(">>");
        buttonNext.setEnabled(false);
        buttonNext.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonNextActionPerformed(evt);
            }
        });

        labelJumpTo.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        labelJumpTo.setText("Jump to:");
        labelJumpTo.setEnabled(false);

        textfieldJump.setEnabled(false);
        textfieldJump.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                textfieldJumpActionPerformed(evt);
            }
        });

        buttonJump.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        buttonJump.setText("GO!");
        buttonJump.setEnabled(false);
        buttonJump.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonJumpActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout panelNavigationLayout = new javax.swing.GroupLayout(panelNavigation);
        panelNavigation.setLayout(panelNavigationLayout);
        panelNavigationLayout.setHorizontalGroup(
            panelNavigationLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelNavigationLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(buttonPrevious)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(labelCurrent, javax.swing.GroupLayout.PREFERRED_SIZE, 75, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(buttonNext)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 63, Short.MAX_VALUE)
                .addComponent(labelJumpTo)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(textfieldJump, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(buttonJump)
                .addContainerGap())
        );
        panelNavigationLayout.setVerticalGroup(
            panelNavigationLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelNavigationLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelNavigationLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(buttonPrevious)
                    .addComponent(labelCurrent)
                    .addComponent(buttonNext)
                    .addComponent(labelJumpTo)
                    .addComponent(textfieldJump, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(buttonJump))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        panelSettings.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Settings", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 0, 11), new java.awt.Color(51, 102, 255))); // NOI18N

        checkSJIS.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        checkSJIS.setText("Convert keystrokes to SJIS");

        checkSkip.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        checkSkip.setText("Don't convert current dialogue to letter pair");

        labelWidth.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        labelWidth.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        labelWidth.setText("Width used:");

        labelWidthTotal.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        labelWidthTotal.setHorizontalAlignment(javax.swing.SwingConstants.LEFT);
        labelWidthTotal.setText("/ 396");

        labelWidthCurrent.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        labelWidthCurrent.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        labelWidthCurrent.setText("0");

        javax.swing.GroupLayout panelSettingsLayout = new javax.swing.GroupLayout(panelSettings);
        panelSettings.setLayout(panelSettingsLayout);
        panelSettingsLayout.setHorizontalGroup(
            panelSettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panelSettingsLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelSettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(panelSettingsLayout.createSequentialGroup()
                        .addComponent(checkSJIS, javax.swing.GroupLayout.PREFERRED_SIZE, 209, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addComponent(checkSkip, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(18, 18, 18)
                .addGroup(panelSettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(labelWidth, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.PREFERRED_SIZE, 137, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, panelSettingsLayout.createSequentialGroup()
                        .addComponent(labelWidthCurrent, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(labelWidthTotal, javax.swing.GroupLayout.PREFERRED_SIZE, 67, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap())
        );
        panelSettingsLayout.setVerticalGroup(
            panelSettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelSettingsLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelSettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(checkSJIS)
                    .addComponent(labelWidth))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(panelSettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(panelSettingsLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(labelWidthTotal)
                        .addComponent(labelWidthCurrent))
                    .addComponent(checkSkip))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        panelOriginal.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Original", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 0, 11), new java.awt.Color(51, 102, 255))); // NOI18N

        textareaOriginal.setColumns(20);
        textareaOriginal.setRows(5);
        textareaOriginal.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                textareaOriginalKeyTyped(evt);
            }
        });
        scrollOriginal.setViewportView(textareaOriginal);

        javax.swing.GroupLayout panelOriginalLayout = new javax.swing.GroupLayout(panelOriginal);
        panelOriginal.setLayout(panelOriginalLayout);
        panelOriginalLayout.setHorizontalGroup(
            panelOriginalLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelOriginalLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(scrollOriginal)
                .addContainerGap())
        );
        panelOriginalLayout.setVerticalGroup(
            panelOriginalLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelOriginalLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(scrollOriginal, javax.swing.GroupLayout.DEFAULT_SIZE, 166, Short.MAX_VALUE)
                .addContainerGap())
        );

        panelEdited.setBorder(javax.swing.BorderFactory.createTitledBorder(null, "Edited", javax.swing.border.TitledBorder.DEFAULT_JUSTIFICATION, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 0, 11), new java.awt.Color(51, 102, 255))); // NOI18N

        textareaEdited.setColumns(20);
        textareaEdited.setRows(5);
        textareaEdited.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                textareaEditedKeyTyped(evt);
            }
        });
        scrollEdited.setViewportView(textareaEdited);

        javax.swing.GroupLayout panelEditedLayout = new javax.swing.GroupLayout(panelEdited);
        panelEdited.setLayout(panelEditedLayout);
        panelEditedLayout.setHorizontalGroup(
            panelEditedLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelEditedLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(scrollEdited, javax.swing.GroupLayout.DEFAULT_SIZE, 430, Short.MAX_VALUE)
                .addContainerGap())
        );
        panelEditedLayout.setVerticalGroup(
            panelEditedLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelEditedLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(scrollEdited)
                .addContainerGap())
        );

        menuFile.setText("File");

        menuitemOpen.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        menuitemOpen.setText("Open...");
        menuitemOpen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemOpenActionPerformed(evt);
            }
        });
        menuFile.add(menuitemOpen);
        menuFile.add(jSeparator1);

        menuitemImport.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_I, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        menuitemImport.setText("Import lines from txt file...");
        menuitemImport.setEnabled(false);
        menuitemImport.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemImportActionPerformed(evt);
            }
        });
        menuFile.add(menuitemImport);

        menuitemExport.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_E, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        menuitemExport.setText("Export lines to txt file...");
        menuitemExport.setEnabled(false);
        menuitemExport.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemExportActionPerformed(evt);
            }
        });
        menuFile.add(menuitemExport);
        menuFile.add(jSeparator3);

        menuitemSave.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        menuitemSave.setText("Save as...");
        menuitemSave.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemSaveActionPerformed(evt);
            }
        });
        menuFile.add(menuitemSave);

        menuitemConvert.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        menuitemConvert.setText("Convert and Save as...");
        menuitemConvert.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemConvertActionPerformed(evt);
            }
        });
        menuFile.add(menuitemConvert);
        menuFile.add(jSeparator2);

        menuitemClose.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ESCAPE, 0));
        menuitemClose.setText("Exit");
        menuitemClose.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemCloseActionPerformed(evt);
            }
        });
        menuFile.add(menuitemClose);

        jMenuBar1.add(menuFile);

        menuNavigate.setText("Navigate");

        menuitemPrevious.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_PAGE_UP, 0));
        menuitemPrevious.setText("Previous");
        menuitemPrevious.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemPreviousActionPerformed(evt);
            }
        });
        menuNavigate.add(menuitemPrevious);

        menuitemNext.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_PAGE_DOWN, 0));
        menuitemNext.setText("Next");
        menuitemNext.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemNextActionPerformed(evt);
            }
        });
        menuNavigate.add(menuitemNext);

        menuitemFirst.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_HOME, java.awt.event.InputEvent.CTRL_MASK));
        menuitemFirst.setText("First");
        menuitemFirst.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemFirstActionPerformed(evt);
            }
        });
        menuNavigate.add(menuitemFirst);

        menuitemLast.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_END, java.awt.event.InputEvent.CTRL_MASK));
        menuitemLast.setText("Last");
        menuitemLast.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemLastActionPerformed(evt);
            }
        });
        menuNavigate.add(menuitemLast);

        jMenuBar1.add(menuNavigate);

        menuTools.setText("Tools");

        menuitemSJIS.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_C, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        menuitemSJIS.setText("Convert edited text to SJIS");
        menuitemSJIS.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemSJISActionPerformed(evt);
            }
        });
        menuTools.add(menuitemSJIS);

        jMenuBar1.add(menuTools);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(panelNavigation, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(panelOriginal, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(panelSettings, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(panelEdited, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(panelNavigation, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(panelSettings, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(panelOriginal, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(panelEdited, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void textareaOriginalKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_textareaOriginalKeyTyped
        // TODO add your handling code here:
        evt.consume();
    }//GEN-LAST:event_textareaOriginalKeyTyped

    private void textareaEditedKeyTyped(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_textareaEditedKeyTyped
        // TODO add your handling code here:
        if (checkSJIS.isSelected())
            filterKeys((javax.swing.JTextArea)evt.getComponent(), evt);
        
        writeWidth(textareaEdited, labelWidthCurrent);
    }//GEN-LAST:event_textareaEditedKeyTyped

    private void menuitemSJISActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemSJISActionPerformed
        // TODO add your handling code here:
        convertToSJIS(textareaEdited);
    }//GEN-LAST:event_menuitemSJISActionPerformed

    private void buttonPreviousActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonPreviousActionPerformed
        // TODO add your handling code here:
        changePage(-1);
    }//GEN-LAST:event_buttonPreviousActionPerformed

    private void buttonNextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonNextActionPerformed
        // TODO add your handling code here:
        changePage(1);
    }//GEN-LAST:event_buttonNextActionPerformed

    private void textfieldJumpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_textfieldJumpActionPerformed
        // TODO add your handling code here:
        buttonJump.doClick();
    }//GEN-LAST:event_textfieldJumpActionPerformed

    private void buttonJumpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonJumpActionPerformed
        // TODO add your handling code here:
        int num_page = Integer.valueOf(textfieldJump.getText());
        jumpTo(num_page - 1);   // We give the illusion that we count pages starting from 1
    }//GEN-LAST:event_buttonJumpActionPerformed

    private void menuitemPreviousActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemPreviousActionPerformed
        // TODO add your handling code here:
        if (buttonPrevious.isEnabled())
            buttonPrevious.doClick();
    }//GEN-LAST:event_menuitemPreviousActionPerformed

    private void menuitemNextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemNextActionPerformed
        // TODO add your handling code here:
        if (buttonNext.isEnabled())
            buttonNext.doClick();
    }//GEN-LAST:event_menuitemNextActionPerformed

    private void menuitemFirstActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemFirstActionPerformed
        // TODO add your handling code here:
        jumpTo(0);
    }//GEN-LAST:event_menuitemFirstActionPerformed

    private void menuitemLastActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemLastActionPerformed
        // TODO add your handling code here:
        if (!script.isEmpty())
            jumpTo(script.size());
    }//GEN-LAST:event_menuitemLastActionPerformed

    private void menuitemCloseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemCloseActionPerformed
        // TODO add your handling code here:
        this.dispose();
    }//GEN-LAST:event_menuitemCloseActionPerformed

    private void menuitemOpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemOpenActionPerformed
        // TODO add your handling code here:
        JFileChooser chooser = new JFileChooser();
        chooser.setCurrentDirectory(new java.io.File(lastDirectory));
        chooser.setDialogTitle("Load SRWL file");
        chooser.setFileFilter(new FileNameExtensionFilter("SRWL file", "SRWL"));
        if (!current_file.isEmpty())
            chooser.setSelectedFile(new File(current_file));

        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION){
            current_file = chooser.getSelectedFile().getName();
            
            openFile(chooser.getSelectedFile().getAbsolutePath());
            
            lastDirectory = chooser.getSelectedFile().getPath();
        }
    }//GEN-LAST:event_menuitemOpenActionPerformed

    private void menuitemSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemSaveActionPerformed
        // TODO add your handling code here:
        if (file_loaded){
            JFileChooser chooser = new JFileChooser();
            chooser.setCurrentDirectory(new java.io.File(lastDirectory));
            chooser.setDialogTitle("Save SRWL file");
            chooser.setFileFilter(new FileNameExtensionFilter("SRWL file", "SRWL"));
            if (!current_file.isEmpty())
                chooser.setSelectedFile(new File(current_file));

            saveDialogue(); // Save the current dialogue, just in case.

            if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION){
                current_file = chooser.getSelectedFile().getName();

                saveFile(chooser.getSelectedFile().getAbsolutePath(), false);

                lastDirectory = chooser.getSelectedFile().getPath();
            }
        }
        else{
            JOptionPane.showMessageDialog(null, "No file loaded!",
                    "Error", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_menuitemSaveActionPerformed

    private void menuitemConvertActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemConvertActionPerformed
        // TODO add your handling code here:
        if (file_loaded){
            JFileChooser chooser = new JFileChooser();
            chooser.setCurrentDirectory(new java.io.File(lastDirectory));
            chooser.setDialogTitle("Save SRWL file");
            chooser.setFileFilter(new FileNameExtensionFilter("SRWL file", "SRWL"));
            if (!current_file.isEmpty())
                chooser.setSelectedFile(new File(current_file));

            saveDialogue(); // Save the current dialogue, just in case.

            if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION){
                current_file = chooser.getSelectedFile().getName();

                saveFile(chooser.getSelectedFile().getAbsolutePath(), true);

                lastDirectory = chooser.getSelectedFile().getPath();
            }
        }
        else{
            JOptionPane.showMessageDialog(null, "No file loaded!",
                    "Error", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_menuitemConvertActionPerformed

    private void menuitemImportActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemImportActionPerformed
        // TODO add your handling code here:
        JFileChooser chooser = new JFileChooser();
        chooser.setCurrentDirectory(new java.io.File(lastDirectory));
        chooser.setDialogTitle("Import from TXT file");
        chooser.setFileFilter(new FileNameExtensionFilter("TXT file", "TXT"));

        if (!current_file.isEmpty()){
            String name = current_file.substring(0, current_file.length()-5) + ".txt";
            chooser.setSelectedFile(new File(name));
        }
        
        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION){
            saveDialogue();

            importTXT(chooser.getSelectedFile().getParent(), chooser.getSelectedFile().getName());

            lastDirectory = chooser.getSelectedFile().getPath();

            loadDialogue();
        }
    }//GEN-LAST:event_menuitemImportActionPerformed

    private void menuitemExportActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemExportActionPerformed
        // TODO add your handling code here:
        JFileChooser chooser = new JFileChooser();
        chooser.setCurrentDirectory(new java.io.File(lastDirectory));
        chooser.setDialogTitle("Export to TXT file");
        chooser.setFileFilter(new FileNameExtensionFilter("TXT file", "TXT"));
        
        if (!current_file.isEmpty())
            chooser.setSelectedFile(new File(current_file.substring(0, current_file.length()-5)));

        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION){
            lastDirectory = chooser.getSelectedFile().getPath();
            
            exportTXT(chooser.getSelectedFile().getAbsolutePath());
        }
    }//GEN-LAST:event_menuitemExportActionPerformed

        
    
    public void openFile(String bin_file){
        parseFile(bin_file);

        labelCurrent.setEnabled(file_loaded);
        labelJumpTo.setEnabled(file_loaded);
        textfieldJump.setEnabled(file_loaded);
        buttonJump.setEnabled(file_loaded);

        current_dialogue = 0;

        updateControls();

        if (!file_loaded){
            textareaOriginal.setText("");
            textareaEdited.setText("");
            labelCurrent.setText("0 / 0");
            buttonNext.setEnabled(false);   // updateControls() doesn't take into account there's no data anymore
            this.setTitle(title);

            JOptionPane.showMessageDialog(null, "The file didn't have any script text!",
                    "Error", JOptionPane.ERROR_MESSAGE);
        }
        else{
            this.setTitle(current_file + " - " + title);
            loadDialogue();
            
            // Enable import option
            menuitemImport.setEnabled(true);
            menuitemExport.setEnabled(true);
        }
    }
    
    
    public void parseFile(String path){
        RandomAccessFile f;
        file_loaded = false;
        //script = new ArrayList<Dialogue>();

        try {
            f = new RandomAccessFile(path, "r");
            byte[] aux = new byte[4];

            // Read the first 4 bytes and see if it starts with SRWL. Abort if it doesn't.
            f.read(aux);

            if (aux[0] != 'S' || aux[1] != 'R' || aux[2] != 'W' || aux[3] != 'L'){
                f.close();

                JOptionPane.showMessageDialog(null, "Wrong format for SRWL file:\n" + path,
                    "Error", JOptionPane.ERROR_MESSAGE);

                return;
            }
            
            // Skip the next 4 bytes
            //f.read(aux);
            f.skipBytes(4); // Not sure if reliable

            // Read the next 4 bytes to determine the number of entries. Abort if 0.
            f.read(aux);

            int num_entries = byteSeqToInt(aux);

            System.out.println("Number of entries: " + num_entries);

            if (num_entries == 0){
                f.close();

                JOptionPane.showMessageDialog(null, "Number of battle lines in the SRWL file: 0",
                    "Error", JOptionPane.ERROR_MESSAGE);

                return;
            }
            
            // Read the next 4 bytes to get the offset of the table
            f.read(aux);
            
            int table_offset = byteSeqToInt(aux);
            
            // Determine the size of the table (will be used later when saving the file)
            // The pointer table is 16-byte alligned, so there's padding needed in most files
            table_size = num_entries * 4;
            
            int rest = table_size % 16;
            
            if (rest != 0)
                table_size += 16 - rest;
            
            // Store everything from the beginning of the file to the start of the pointer table
            f.seek(0);
            
            first_section = new byte[table_offset];
            
            f.read(first_section);

            // Grab the pointer table
            byte[] table = new byte[num_entries*4];
            f.read(table);

            // Read the offsets for the entries and save said entries as byte arrays
            byte[][] entries = new byte[num_entries][];
            int start = 0;  // Start of the entry
            int end = 0;    // End of the entry
            byte[] chunk = new byte[1];

            //int offset = 8;
            int offset = table_offset;  // Start at the beginning of the table
            f.seek(offset);

            for (int i = 0; i < num_entries; i++){
                f.read(aux);
                offset += 4;
                start = byteSeqToInt(aux);

                if (i < num_entries - 1){
                    f.read(aux);
                    end = byteSeqToInt(aux);
                    end--;
                }
                else{   // Find where the line ends
                    //end = (int) f.length();
                    end = start;
                    boolean stop = false;
                    
                    do{
                        f.seek(end);
                        f.read(chunk);
                        
                        if (chunk[0] == 0)
                            stop = true;
                        else
                            end++;
                    } while (!stop);
                }

                //System.out.println("Start: " + start + " - End: " + end);

                entries[i] = new byte[end - start];

                f.seek(start);
                f.read(entries[i]);

                f.seek(offset);
            }

            f.close();

            
            // Store all the read entries as dialogues
            script = new ArrayList<> ();    // It would be better to use a normal array, but reusing code is a bitch
            Dialogue d;
            
            for (int i = 0; i < num_entries; i++){
                String text = new String(entries[i], font_encoding);
                
                String[] lines = text.split("@");   // Break into lines
                
                text = lines[0];
                
                for (int j = 1; j < lines.length; j++)
                    text += "\n" + lines[j];

                // Create a dialogue with all the data found and insert it in the script
                d = new Dialogue(text, text, "", false);

                script.add(d);
            }
            
            
            // Enable navigation
            file_loaded = true;
            labelCurrent.setEnabled(true);
            labelJumpTo.setEnabled(true);
            textfieldJump.setEnabled(true);
            buttonJump.setEnabled(true);

            // Load first set of lines
            current_dialogue = 0;
            updateControls();
            loadDialogue();

        } catch (IOException ex) {
            Logger.getLogger(UserInterfaceSE.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    
    public void importTXT(String absolute_path, String filename){
        try {
            String translated = "";
            String line;
            
            Path path = FileSystems.getDefault().getPath(absolute_path, filename);
            BufferedReader br = Files.newBufferedReader(path, Charset.forName(font_encoding));
            
            ArrayList<String> readLines = new ArrayList();
            
            // Acquire all lines in the TXT file and store them
            while( (line = br.readLine()) != null){
                if (line.isEmpty() || line.startsWith("//")){   // Empty line or comment
                    if (!translated.isEmpty()){ // The translated line is finished. Store the line
                        readLines.add(translated);
                        
                        //System.out.println("Translated: " + translated);

                        // Empty the auxiliary strings
                        translated = "";
                    }
                }
                else{   // Text line
                    //line.replaceAll("[male-name]", "#男姓名");
                    //line.replaceAll("[female-name]", "#女姓名");
                    //line.replaceAll("[male-nickname]", "#男愛称");
                    //line.replaceAll("[female-nickname]", "#女愛称");
                    //line.replaceAll("[mecha-name]", "#機体名");
                    
                    line = replaceStrings(line, "[male-name]", "#男姓名");
                    line = replaceStrings(line, "[female-name]", "#女姓名");
                    line = replaceStrings(line, "[male-nickname]", "#男愛称");
                    line = replaceStrings(line, "[female-nickname]", "#女愛称");
                    line = replaceStrings(line, "[mecha-name]", "#機体名");

                    if(translated.isEmpty())
                        translated = line;
                    else
                        translated += "\n" + line;
                }
            }
            
            if (!translated.isEmpty()){ // There was no empty line after the last translated line
                readLines.add(translated);
                
                //System.out.println("Translated: " + translated);
            }
            
            if (readLines.size() == script.size()){
                for (int i = 0; i < script.size(); i++){
                    script.get(i).edited = readLines.get(i);
                }
                
                System.out.println("Import complete.");
            }
            else{   // Error
                JOptionPane.showMessageDialog(null, "Wrong number of script lines:" +  readLines.size(),
                    "ERROR", JOptionPane.ERROR_MESSAGE);
            }
        } catch (IOException ex) {
            Logger.getLogger(UserInterfaceSE.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    // Replaces all occurrences of "search" inside "line" with "change"
    public String replaceStrings(String line, String search, String change){
        int pos = line.indexOf(search);

        while (pos != -1){
            String start = line.substring(0, pos);
            //String special = line.substring(pos, pos + search.length());
            String end = line.substring(pos + search.length());

            //if (special.equals("[male-name]"))
            //    special = "#男姓名";

            line = start + change + end;

            pos = line.indexOf(search);
        }
        
        return line;
    }
    
    
    public void exportTXT(String filename){
        try {
            if (!filename.endsWith(".txt") && !filename.endsWith(".TXT")){
                filename += ".txt";
                
                lastDirectory += ".txt";
            }
            
            FileOutputStream fos = new FileOutputStream(filename);
            Writer out = new OutputStreamWriter(fos, font_encoding);
            
            //Map<String, String> map = new TreeMap();
            
            // Print a header for the file
            String header = "// All lines starting with '//' are comments and won't be used when importing the file.\n"
                    + "// You can add your own comments before or after a translated message, but not in the middle.\n"
                    + "// The original script lines are left as comments for reference. Please edit the uncommented lines.\n"
                    + "// A message can have 3 lines at most. The máximum number of characters per line is 44 (name included).\n"
                    + "// A line can have more than that, but the text gets shrinked ingame then, so avoid it.\n\n";
            
            out.write(header);
            
            
            for (int i = 0; i < script.size(); i++){
                //if (map.get(script.get(i).original) == null){ // Quote hasn't been written before
                    //out.write(script.get(i).original + "\n\n" + script.get(i).edited + "\n\n");

                    //map.put(script.get(i).original, script.get(i).edited);
                //}
                
                String number = "";
                
                if (i < 1000)
                    number += "0";
                if (i < 100)
                    number += "0";
                
                number += i;
                
                out.write("// #" + number + "\n");
                
                String[] lines = script.get(i).original.split("\n");
                
                for (int j = 0; j < lines.length; j++){
                    out.write("//" + lines[j] + "\n");
                }
                
                out.write("\n");
                
                lines = script.get(i).edited.split("\n");
                
                //out.write("\n" + script.get(i).edited + "\n\n");
                
                for (int j = 0; j < lines.length; j++){
                    //lines[j].replaceAll("#男姓名", "[male-name]");
                    //lines[j].replaceAll("#女姓名", "[female-name]");
                    //lines[j].replaceAll("#男愛称", "[male-nickname]");
                    //lines[j].replaceAll("#女愛称", "[female-nickname]");
                    //lines[j].replaceAll("#機体名", "[mecha-name]");
                    
                    if (lines[j].contains("#")){
                        int pos = lines[j].indexOf("#");
                        
                        while (pos != -1){
                            String start = lines[j].substring(0, pos);
                            String special = lines[j].substring(pos, pos+4);
                            String end = lines[j].substring(pos+4);
                            
                            if (special.equals("#男姓名"))
                                special = "[male-name]";
                            else if (special.equals("#女姓名"))
                                special = "[female-name]";
                            else if (special.equals("#男愛称"))
                                special = "[male-nickname]";
                            else if (special.equals("#女愛称"))
                                special = "[female-nickname]";
                            else if (special.equals("#機体名"))
                                special = "[mecha-name]";
                            else
                                special = "[unknown]";
                            
                            lines[j] = start + special + end;
                            
                            pos = lines[j].indexOf("#");
                        }
                    }
                    
                    out.write(lines[j] + "\n");
                }
                
                out.write("\n");
            }
            
            out.close();
            
            JOptionPane.showMessageDialog(null, "Exported battle quotes:" +  script.size(),//map.size(),
                    "Done", JOptionPane.INFORMATION_MESSAGE);
        } catch (IOException e) {
            e.printStackTrace();
}
    }
    
    
    public void saveFile(String path, boolean use_converted){
        //int table_size = script.size() * 4;
        byte[] table = new byte[table_size];
        byte[] padding = null;

        int offset = table_size;
        int size = first_section.length;

        ByteArrayOutputStream os = new ByteArrayOutputStream( );

        try{
            if (use_converted){ // Convert the edited text into letter pairs first
                for (int i = 0; i < script.size(); i++){
                    script.get(i).convertLetterPairs();
                }
            }
            
            // Prepare the table and the battle lines' data
            for (int i = 0; i < script.size(); i++){
                // Write offset in the table
                int written_offset = offset + first_section.length;
                table[i*4] = (byte) ( written_offset & 0xff );
                table[i*4 + 1] = (byte) ( (written_offset >> 8)  & 0xff );
                table[i*4 + 2] = (byte) ( (written_offset >> 16) & 0xff );
                table[i*4 + 3] = (byte) ( (written_offset >> 24) & 0xff );

                byte[] aux = null;

                aux = script.get(i).getBytes(use_converted && !script.get(i).skip);
                offset += aux.length;

                os.write(aux);
            }
            
            size += offset;
            
            // Calculate the padding of the file
            // SRWL files are 2048-byte alligned
            int rest = size % 2048;
            if (rest != 0)
                padding = new byte[2048 - rest];

            // Write everything into the file
            RandomAccessFile f = new RandomAccessFile(path, "rw");
            
            // Truncate the file (in case we're overwriting)
            f.setLength(0);

            f.write(first_section);
            f.write(table);
            f.write(os.toByteArray());
            
            if (padding != null)
                f.write(padding);

            f.close();

            System.out.println("File " + path + " saved successfully.");    // END

        } catch(IOException ex){
            JOptionPane.showMessageDialog(null, "Could not write file to disk!",
                    "Error", JOptionPane.ERROR_MESSAGE);
            Logger.getLogger(UserInterfaceSE.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    
    // Takes a 4-byte hex little endian and returns its int value
    // Takes little endian values
    public int byteSeqToInt(byte[] byteSequence){
        if (byteSequence.length != 4)
            return -1;

        int value = 0;
        value += byteSequence[0] & 0xff;
        value += (byteSequence[1] & 0xff) << 8;
        value += (byteSequence[2] & 0xff) << 16;
        value += (byteSequence[3] & 0xff) << 24;
        return value;
    }


    public String hex2string(byte[] sjis_bytes){
        String sjis_text = "";

        try {
            sjis_text = new String(sjis_bytes, font_encoding);
        } catch (UnsupportedEncodingException ex) {
            Logger.getLogger(UserInterfaceSE.class.getName()).log(Level.SEVERE, null, ex);
        }

        return sjis_text;
    }
    
    
    public void saveDialogue(){
            script.get(current_dialogue).edited = textareaEdited.getText();
            script.get(current_dialogue).skip = checkSkip.isSelected();
    }

    
    public void loadDialogue(){
        textareaOriginal.setText(script.get(current_dialogue).original);
        textareaEdited.setText(script.get(current_dialogue).edited);
        checkSkip.setSelected(script.get(current_dialogue).skip);

        writeWidth(textareaEdited, labelWidthCurrent);
    }

    
    public void changePage(int delta){
        saveDialogue();
        current_dialogue += delta;
        loadDialogue();

        updateControls();
    }

    
    public void jumpTo(int num){
        saveDialogue();

        current_dialogue = num;

        if (num < 0)
            current_dialogue = 0;
        else if (current_dialogue > (script.size() - 2) )
            current_dialogue = (script.size() - 1);

        //System.out.println("current: " + current_dialogue + " max: " + script.size());
        loadDialogue();

        updateControls();
    }


    public void updateControls(){
        labelCurrent.setText( (current_dialogue + 1) + " / " + script.size() );
        buttonPrevious.setEnabled(current_dialogue != 0);
        buttonNext.setEnabled(current_dialogue != script.size() - 1);
    }

    
    
    public void writeWidth(javax.swing.JTextArea ta, javax.swing.JLabel la){
        int width = 0;

        String text = ta.getText();

        if (!text.isEmpty()){
            String[] lines = text.split("\n");

            for (int i = 0; i < lines.length; i++){
                int line_size = 0;
                //line_size = lines[i].length() * 18; // Each character is 18x18 in the original
                for (int j = 0; j < lines[i].length(); j++){
                    char c = lines[i].charAt(j);
                    if (c < '　')   // Empty space in SJIS, pretty much the first possible character in SJIS
                        line_size += 9;    // We add the width of an ASCII character
                    else{
                        line_size += 18;    // We add the width of a SJIS character
                    }
                    
                    if (line_size > width)
                        width = line_size;
                }
            }
        }

        la.setText("" + width);
        if (width > 396)    // 44 characters by line, at 9 pixels width
            la.setForeground(new Color(255, 0, 0));
        else
            la.setForeground(new Color(0, 0, 0));
    }

    
    // Changes your typed character in JTextArea t to its SJIS version
    public void filterKeys(javax.swing.JTextArea t, java.awt.event.KeyEvent e){
        char original_char = e.getKeyChar();
        boolean change = false;

        byte[] sjis_char = charToSJIS(original_char);
        if (sjis_char[0] != 0)
            change = true;

        if (change){
            try {
                t.replaceSelection(""); // Cleans the selected text
                e.consume();
                int pos = t.getCaretPosition();
                String text = t.getText();
                String new_char = new String(sjis_char, font_encoding);
                //System.out.println("caret: " + pos + " length: " + text.length());
                if (pos == 0)
                    text = new_char + t.getText();
                else if (pos == text.length())
                    text = t.getText() + new_char;
                else
                    text = text.substring(0, pos) + new_char + text.substring(pos, text.length());
                //String text = textfieldTest.getText() + new String(sjis_char, "Shift-JIS");
                t.setText(text);
                t.setCaretPosition(pos + 1);
            } catch (UnsupportedEncodingException ex) {
                Logger.getLogger(UserInterfaceSE.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }


    public byte[] charToSJIS(char c){
        /*
            0 = 48 -> 82 4f
            9 = 57 -> 82 58

            A = 65 -> 82 60
            Z = 90 -> 82 79

            a = 97 -> 82 81
            z = 122 -> 82 9a

            space -> 81 40
            , -> 81 41
            . -> 81 42
         */
        byte[] Jap_char = new byte[2];
        Jap_char[0] = (byte) 0x82;
        if (c >= 'a' && c <= 'z'){
            Jap_char[1] = (byte) 0x81;
            Jap_char[1] += c - 'a';
        }
        else if (c >= 'A' && c <= 'Z'){
            Jap_char[1] = (byte) 0x60;
            Jap_char[1] += c - 'A';
        }
        else if (c >= '0' && c <= '9'){
            Jap_char[1] = (byte) 0x4f;
            Jap_char[1] += c - '0';
        }
        else{ // Check if it's a special character
            int code = c;
            Jap_char[0] = (byte) 0x81;
            switch (code){
                case 32: // space = 32 -> 81 40
                    Jap_char[1] = (byte) 0x40;
                    break;
                case 33: // ! = 33 -> 81 49
                    Jap_char[1] = (byte) 0x49;
                    break;
                case 34: // " = 34 -> 81 8d
                    Jap_char[1] = (byte) 0x8d;
                    break;
                case 35: // # = 35 -> 81 94
                    Jap_char[1] = (byte) 0x94;
                    break;
                case 37: // % = 37 -> 81 93
                    Jap_char[1] = (byte) 0x93;
                    break;
                case 38: // & = 38 -> 81 95
                    Jap_char[1] = (byte) 0x95;
                    break;
                case 39: // ' = 39 -> 81 8c
                    Jap_char[1] = (byte) 0x8c;
                    break;
                case 40: // ( = 40 -> 81 69
                    Jap_char[1] = (byte) 0x69;
                    break;
                case 41: // ) = 41 -> 81 6a
                    Jap_char[1] = (byte) 0x6a;
                    break;
                case 42: // * = 42 -> 81 96
                    Jap_char[1] = (byte) 0x96;
                    break;
                case 43: // + = 43 -> 81 7b
                    Jap_char[1] = (byte) 0x7b;
                    break;
                case 44: // , = 44 -> 81 43
                    Jap_char[1] = (byte) 0x43;
                    break;
                case 45: // - = 45 -> 81 7c
                    Jap_char[1] = (byte) 0x7c;
                    break;
                case 46: // . = 46 -> 81 44
                    Jap_char[1] = (byte) 0x44;
                    break;
                case 47: // / = 47 -> 81 5e
                    Jap_char[1] = (byte) 0x5e;
                    break;
                case 58: // : = 58 -> 81 46
                    Jap_char[1] = (byte) 0x46;
                    break;
                case 59: // ; = 59 -> 81 47
                    Jap_char[1] = (byte) 0x47;
                    break;
                case 60: // < = 60 -> 81 83
                    Jap_char[1] = (byte) 0x83;
                    break;
                case 61: // = = 61 -> 81 81
                    Jap_char[1] = (byte) 0x81;
                    break;
                case 62: // > = 62 -> 81 84
                    Jap_char[1] = (byte) 0x84;
                    break;
                case 63: // ? = 63 -> 81 48
                    Jap_char[1] = (byte) 0x48;
                    break;
                case 64: // @ = 64 -> 81 97
                    Jap_char[1] = (byte) 0x97;
                    break;
                default:
                    Jap_char[0] = 0;
                    Jap_char[1] = 0;
            }
        }
        return Jap_char;
    }


    public void convertToSJIS(javax.swing.JTextArea t){
        String text = t.getText();
        String newText = "";

        for (int i = 0; i < text.length(); i++){
            char c = text.charAt(i);
            byte[] sjis_char = charToSJIS(c);

            if (sjis_char[0] != 0){
                try {
                    String new_char = new String(sjis_char, font_encoding);

                    newText += new_char;
                } catch (UnsupportedEncodingException ex) {
                    Logger.getLogger(UserInterfaceSE.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
            else{
                newText += c;
            }
        }

        t.setText(newText);
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton buttonJump;
    private javax.swing.JButton buttonNext;
    private javax.swing.JButton buttonPrevious;
    private javax.swing.JCheckBox checkSJIS;
    private javax.swing.JCheckBox checkSkip;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JPopupMenu.Separator jSeparator1;
    private javax.swing.JPopupMenu.Separator jSeparator2;
    private javax.swing.JPopupMenu.Separator jSeparator3;
    private javax.swing.JLabel labelCurrent;
    private javax.swing.JLabel labelJumpTo;
    private javax.swing.JLabel labelWidth;
    private javax.swing.JLabel labelWidthCurrent;
    private javax.swing.JLabel labelWidthTotal;
    private javax.swing.JMenu menuFile;
    private javax.swing.JMenu menuNavigate;
    private javax.swing.JMenu menuTools;
    private javax.swing.JMenuItem menuitemClose;
    private javax.swing.JMenuItem menuitemConvert;
    private javax.swing.JMenuItem menuitemExport;
    private javax.swing.JMenuItem menuitemFirst;
    private javax.swing.JMenuItem menuitemImport;
    private javax.swing.JMenuItem menuitemLast;
    private javax.swing.JMenuItem menuitemNext;
    private javax.swing.JMenuItem menuitemOpen;
    private javax.swing.JMenuItem menuitemPrevious;
    private javax.swing.JMenuItem menuitemSJIS;
    private javax.swing.JMenuItem menuitemSave;
    private javax.swing.JPanel panelEdited;
    private javax.swing.JPanel panelNavigation;
    private javax.swing.JPanel panelOriginal;
    private javax.swing.JPanel panelSettings;
    private javax.swing.JScrollPane scrollEdited;
    private javax.swing.JScrollPane scrollOriginal;
    private javax.swing.JTextArea textareaEdited;
    private javax.swing.JTextArea textareaOriginal;
    private javax.swing.JTextField textfieldJump;
    // End of variables declaration//GEN-END:variables
}
